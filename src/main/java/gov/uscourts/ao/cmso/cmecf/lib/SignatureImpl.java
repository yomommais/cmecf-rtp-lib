package gov.uscourts.ao.cmso.cmecf.lib;

import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;
import java.util.TreeMap;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;

import org.apache.http.NameValuePair;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.message.BasicNameValuePair;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class SignatureImpl implements Signature {
	
	private final static Logger LOG = LogManager.getLogger(Signature.class);

	public String generateAxWaySignature(String httpMethod, String gatewayHost, String path, String payload) {
		
		final String API_KEY = "29ebbab6-88ce-4037-bf39-8b79d6798969";
		final String API_SECRET = "2d11c518-36ae-4aed-902b-10c4eaed2ba4";
		final String VERSION_PREFIX = "APIGWY";
		final String SIGNATURE_VERSION = "1";
		
		LOG.debug("generateAxWaySignature invoked...");
		
		LOG.debug("API_KEY           = " + API_KEY);
		LOG.debug("API_SECRET        = " + API_SECRET);
		LOG.debug("DATE_HEADER       = " + Constants.AXWAY_DATE_HEADER);
		LOG.debug("SIGNATURE_HEADER  = " + Constants.AXWAY_SIGNATURE_HEADER);
		LOG.debug("VERSION_PREFIX    = " + VERSION_PREFIX);
		LOG.debug("SIGNATURE_VERSION = " + SIGNATURE_VERSION);
		
		LOG.debug("httpMethod        = " + httpMethod);
		LOG.debug("gatewayHost       = " + gatewayHost);
		LOG.debug("path              = " + path);
		LOG.debug("payload           = " + payload);

		// If there are query URL args, format them. For signature calculation,
		// query string parameters must be sorted in code point order from low
		// to high and their values must be URI-encoded.

		String parameters = "";

		if (path.contains("?")) {
			TreeMap<String, String> queryString = ParseAndFormatQueryString(path);
			parameters = BuildURLParametersString(queryString);
		}

		String signature = generateCoreSignature(gatewayHost, path, parameters, payload, httpMethod,
				API_KEY, API_SECRET, Constants.AXWAY_DATE_HEADER, Constants.AXWAY_SIGNATURE_HEADER, VERSION_PREFIX, SIGNATURE_VERSION);
		
		return signature;
	}

	public String generateCoreSignature(String gatewayHost, String path, String parameters, String payload, String httpMethod, 
			String apiKey, String apiSecret, String dateHeader, String signatureHeader, String versionPrefix, String signatureVersion) {

		String canonicalUri = "";
		String signature = "";
		String signedSignature = "";

		LOG.debug("generating core signature...");

		LOG.debug("generating UTC time...");
		SimpleDateFormat sdFormat = new SimpleDateFormat("yyyyMMdd'T'HH:mm:ss'Z'");
		sdFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
		String utcTime = sdFormat.format(new Date());

		// Create a canonical request.

		TreeMap<String, String> sortedQueryStrings = new TreeMap<String, String>();

		if (parameters.length() > 0) {
			
			// generated by java code has "?" as the first character followed by the
			// querystring parameters. Remove "?"
			parameters = parameters.substring(1);

			for (String qString : parameters.split("&")) {
				
				String[] currentQueryString = qString.split("=");
				
				try {
					sortedQueryStrings.put(currentQueryString[0], java.net.URLEncoder.encode(currentQueryString[1], StandardCharsets.UTF_8.toString()));
					
				} catch (UnsupportedEncodingException e) {
					
					String str = "error parsing querystring " + parameters + " : " + e.getMessage();
					LOG.error(str);
					return errStr(str);
				}
			}
		}

		StringBuilder modifiedQueryStrings = new StringBuilder();
		
		for (Map.Entry<String, String> sqString : sortedQueryStrings.entrySet()) {
			modifiedQueryStrings.append(sqString.getKey()).append("=").append(sqString.getValue()).append("&");
		}

		if (modifiedQueryStrings.length() > 0) {
			modifiedQueryStrings.deleteCharAt(modifiedQueryStrings.length() - 1);
		}

		TreeMap<String, String> sortedHeaders = new TreeMap<String, String>();
		sortedHeaders.put(dateHeader.trim().toLowerCase(), utcTime);
		sortedHeaders.put("Host".trim().toLowerCase(), gatewayHost);

		StringBuilder modifiedHeaders = new StringBuilder();
		StringBuilder modifiedSignedHeaders = new StringBuilder();

		for (Map.Entry<String, String> header : sortedHeaders.entrySet()) {
			modifiedHeaders.append(header.getKey()).append(":").append(header.getValue()).append("\n");
			modifiedSignedHeaders.append(header.getKey()).append(";");
		}

		if (modifiedHeaders.length() > 0) {
			modifiedSignedHeaders.deleteCharAt((modifiedSignedHeaders.length() - 1));
		}

		// Step 1 is to define the verb (GET, POST, etc.)--already done.

		// Step 2: Create canonical URI--the part of the URI from domain to query
		// string (use '/' if no path)

		if (path.contains("?")) {
			canonicalUri = path.substring(0, path.indexOf("?"));
		} else {
			canonicalUri = path;
		}

		// Step 3: Create the canonical query string. In this example (a GET request),
		// request parameters are in the query string. Query string values must
		// be URL-encoded (space=%20). The parameters must be sorted by name.
		// For this example, the query string is pre-formatted in the request_parameters
		// variable.

		String canonicalQueryString = modifiedQueryStrings.toString();
		LOG.debug("cannonicalQueryString = " + canonicalQueryString);

		// Step 4: Create the canonical headers and signed headers. Header names
		// must be trimmed and lowercase, and sorted in code point order from
		// low to high. Note that there is a trailing \n.

		String canonicalHeaders = modifiedHeaders.toString();
		LOG.debug("canonicalHeaders = " + canonicalHeaders);

		// Step 5: Create the list of signed headers. This lists the headers
		// in the canonical_headers list, delimited with ";" and in alpha order.
		// Note: The request can include any headers; canonical_headers and
		// signed_headers lists those that you want to be included in the
		// hash of the request. "Host" and "us-courts-apigwy-date" are always required.

		String signedHeaders = modifiedSignedHeaders.toString();
		LOG.debug("signedHeaders = " + signedHeaders);

		// Step 6: Create payload hash (hash of the request body content). For GET
		// requests, the payload is an empty string ("").

		MessageDigest digest;
		try {
			LOG.debug("getting instance of message digest...");
			digest = MessageDigest.getInstance("SHA-256");
			LOG.debug("digest = " + digest);
			
		} catch (NoSuchAlgorithmException e) {
			
			String str = "no such algorithm: " + e.getMessage();
			LOG.error(str);
			return errStr(str);
		}

		LOG.debug("creating payload hash...");
		String payloadHash = DatatypeConverter.printHexBinary(digest.digest(payload.getBytes(StandardCharsets.UTF_8))).toLowerCase();
		LOG.debug("payloadHash = " + payloadHash);

		// Step 7: Combine elements to create canonical request

		String canonicalRequest = httpMethod + '\n' + canonicalUri + '\n' + canonicalQueryString + '\n' + canonicalHeaders + '\n'
		    + signedHeaders + '\n' + payloadHash;
		
		LOG.debug("canonicalRequest = " + canonicalRequest);

		// Match the algorithm to the hashing algorithm you use, either SHA-1 or SHA-256
		// (recommended)

		String algorithm = versionPrefix + signatureVersion + "-HMAC-SHA256";
		LOG.debug("algorithm = " + algorithm);
		
		String stringToSign = algorithm + '\n' + utcTime + '\n' + DatatypeConverter.printHexBinary(digest.digest(canonicalRequest.getBytes(StandardCharsets.UTF_8))).toLowerCase();
		LOG.debug("stringToSign = " + stringToSign);

		// Create the signing key using the function defined above.

		LOG.debug("creating singing key...");
		String signingKey;
		
		try {
			signingKey = GetSignatureKey(apiSecret, utcTime, signatureVersion, versionPrefix);
			LOG.debug("signingKey = " + signingKey);
			
		} catch (InvalidKeyException e) {
			
			String str = "invalid key exception: " + e.getMessage();
			LOG.error(str);
			return errStr(str);
			
		} catch (NoSuchAlgorithmException e) {
			
			String str = "no such algorithm: " + e.getMessage();
			LOG.error(str);
			return errStr(str);
		}

		// Sign the string_to_sign using the signing_key

		LOG.debug("signing the string using signing key...");

		Mac sha256_HMAC;
		try {
			sha256_HMAC = Mac.getInstance("HmacSHA256");
			LOG.debug("sha256_HMAC = " + sha256_HMAC);
			
		} catch (NoSuchAlgorithmException e) {
			
			String str = "no such algorithm: " + e.getMessage();
			LOG.error(str);
			return errStr(str);
		}

		SecretKeySpec final_signing_key = new SecretKeySpec(signingKey.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
		LOG.debug("final_signing_key = " + final_signing_key);

		try {
			LOG.debug("signing...");
			sha256_HMAC.init(final_signing_key);
			
		} catch (InvalidKeyException e) {
			
			String str = "invalid key exception: " + e.getMessage();
			LOG.error(str);
			return errStr(str);
		}

		signature = DatatypeConverter.printHexBinary(sha256_HMAC.doFinal(stringToSign.getBytes(StandardCharsets.UTF_8))).toLowerCase();
		LOG.debug("signature = " + signature);

		signedSignature = Constants.GOOD + Constants.DELIMITER + utcTime + Constants.DELIMITER + algorithm + " " + "Credential=" + apiKey + ", " + "SignedHeaders=" + signedHeaders + ", "
		    + "Signature=" + signature;

		LOG.debug("signedSignature = " + signedSignature);
		return signedSignature;
	}

	private String GetSignatureKey(String secretKey, String timestamp, String signatureVersion, String versionPrefix)
	    throws NoSuchAlgorithmException, InvalidKeyException {
		
		String kDate = Sign(versionPrefix + signatureVersion + secretKey, timestamp);
		String kSigning = Sign(kDate, versionPrefix.toLowerCase() + signatureVersion + "_request");
		
		return kSigning;
	}

	private String Sign(String key, String message) throws NoSuchAlgorithmException, InvalidKeyException {
		String hash = "";

		Mac sha256_HMAC = Mac.getInstance("HmacSHA256");
		SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
		sha256_HMAC.init(secret_key);
		
		hash = DatatypeConverter.printHexBinary(sha256_HMAC.doFinal(message.getBytes(StandardCharsets.UTF_8))).toLowerCase();
		
		return hash;
	}

	private String BuildURLParametersString(TreeMap<String, String> parameters) {
		
		List<NameValuePair> nvPairList = new ArrayList<NameValuePair>();
		
		for (Map.Entry<String, String> currentParameter : parameters.entrySet()) {
			nvPairList.add(new BasicNameValuePair(currentParameter.getKey(), currentParameter.getValue()));
		}
		
		URIBuilder builder = new URIBuilder().addParameters(nvPairList);
		return builder.toString();
	}

	private TreeMap<String, String> ParseAndFormatQueryString(String path) {
		
		TreeMap<String, String> formattedQueryString = new TreeMap<String, String>();
		String queryString = path.substring(path.indexOf("?") + 1, path.length());
		
		for (String currentPair : queryString.split("&")) {
			String[] entry = currentPair.split("=");
			formattedQueryString.put(entry[0], entry[1]);
		}
		
		return formattedQueryString;
	}
	
	private String errStr(String str) {
		return Constants.BAD + Constants.DELIMITER + str;
	}
}
